<!doctype html>
<html>
    <head>
        <meta charset="utf-8">

        <title></title>

        <meta name="description" content="Slides">
        <meta name="author" content="Laurent Belcour">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="ext/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="ext/webgl/css/unity-white.css" id="theme">
        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet"> 
        <style>
            @font-face {
                font-family: Ubuntu, sans-serif;
            }
        </style>

        <script src="ext/jquery/dist/jquery.min.js"></script>
        <script src="ext/Snap.svg/dist/snap.svg-min.js"></script>
        <script src="ext/headjs/dist/1.0.0/head.min.js"></script>
        <script src="ext/reveal.js/js/reveal.js"></script>
        <script src="ext/webgl/scripts/shaders.js"></script>
        <script src="ext/webgl/scripts/utils.js"></script>
        <script src="ext/threejs/three.min.js"></script>
    </head>
    <body>
        <script>
            Shaders.init('./ext/webgl/');
        </script>
        <script type="x-shader/x-vertex" id="vertexshader">
            varying vec3 vNormal;
            varying vec4 vPosition;

            void main() {
                vNormal   = normal;
                vPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                gl_Position = vPosition;
            }
        </script>
        <script type="x-shader/x-vertex" id="fragmentshader">
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        </script>
        <div class="reveal">
            <div class="slides">
                <!-- Title slides -->
                <section class="title">
                    <h2 style="padding-bottom:7%; padding-top:15%;text-align: center;">
                        Efficient Rendering of Layered Materials<br />
                        <span style="font-size: 72%;">using an Atomic Decomposition with Statistical Operators</span>
                    </h2>
                    <div style="width:100%; font-size: 0.8em; display: flex; justify-content:space-evenly;">
                        <div style="">
                            Laurent Belcour<br />
                            <!-- <hr /> -->
                            <img class="plain" style="width:120px; margin:20px 0px 0px 10px;" src="./images/png/logos/unity-black.png" />
                            <!-- <small>Unity Technologies</small> -->
                        </div>
                    </div>
                    <aside class="notes">
                        Thank you for coming to this talk.<br /><br/>

                        Before I start, I would like to talk a little bit about how I came to work on such a topic.
                    </aside>
                </section>

                <!-- Motivation / History slides -->
                <section>
                    <h2>Last Year ...</h2>
                    <center>
                        <video id="irid_ff_video" height="500px" controls src="./videos/fast-forward.mov#t=17,29">
                        </video><br />
                        <small style="width:890px;text-align:right;font-size:0.6em;">Rendered in Unity</small>
                    </center>
                    <div class="fragment" id="irid_ff_video_play"></div>
                    <aside class="notes">
                        Last year, I presented a technical paper on real-time rendering of iridescence produced by thin-film interference. Here is a snippet of the fast forward. This part was rendered in the engine Unity.
                    </aside>
                    <script>
                           Reveal.addEventListener('ready', function( event ) {
                                var video = $("#irid_ff_video")[0];
                                video.currentTime = 17;
                                video.volume = 0.5;
                           });
                           Reveal.addEventListener('fragmentshown', function( event ) {
                                if(event.fragment.id == 'irid_ff_video_play') {
                                    $("#irid_ff_video")[0].play();
                                }
                           });
                           Reveal.addEventListener('fragmenthidden', function( event ) {
                                if(event.fragment.id == 'irid_ff_video_play') {
                                    var video = $("#irid_ff_video")[0];
                                    video.stop();
                                    video.currentTime = 17;
                                }
                           });
                    </script>
                </section>
                <section>
                    <h2>Last Year ...</h2>
                    <div style="display: flex;">
                        <div style="width:550px; margin:0px 10px 0px 50px;">
                              <ul>
                                    <li style="padding-top:40px;">Rendering thin-film iridescence
                                        <ul>
                                            <li>Using a <em>clear-coat</em> plugin in Mitsuba</li>
                                            <li class="fragment" data-fragment-index="2">But no <em>clear-coat</em> available in Unity &#128557;</li>
                                        </ul>
                                    </li>
                                    <li class="fragment"  data-fragment-index="3" style="padding-top:20px;">I wanted to show the beetle live
                                        <ul>
                                            <li>One solution: code one in time!</li>
                                        </ul>
                                    </li>
                                    <li class="fragment"  data-fragment-index="4" style="padding-top:20px;">Turn out we can do much more
                                        <ul>
                                            <li>Multiple rough interfaces</li>
                                            <li>Energy conservation</li>
                                            <li>...</li>
                                        </ul>
                                    </li>
                              </ul>
                        </div>
                        <div style="width: 550px; padding-top:90px;"><center>
                            <img src="images/png/beetle/beetle-our.png" />
                            <div style="width:500px; text-align:right; font-size: 0.6em;">Rendered in Mitsuba</div>
                        </center></div>
                    </div>
                    <div class="fragment fade-out" data-fragment-index="3">
                        <img class="fragment fade-in" data-fragment-index="1" src="images/svg/clearcoat.svg" style="border:none; position:absolute; top:300px; left:600px; width:300px;"/>
                    </div>
                    <aside class="notes">
                        With this car shot, I wanted to reproduce this Mitsuba rendering from last year's paper but in real-time. <strong>click</strong> This rendering used the clear-coat plugin on top of the iridescent one. The idea behind the clear-coat plugin is quite simple. The view ray is bent with respect to Snell's law and is used to sample the base BSDF. All those reflected rays are then bent to get out of the clear-coat. While this fails to account for multiple scattering in the clear-coat, it correctly follows light transport. <strong>click</strong> However, getting a physically based clear-coat in a real-time renderer is much more challenging. There, because IBL and area-lights are preintegrated so you cannot bent ray like mitsuba does. So people do a lot of hacks that are ... what they are. While they are efficient, they seem to take an different definition of physically based rendering. <strong>click</strong> <br /><br />

                        That didn't stop me from trying to make it. Only, I had to build it from the ground up and in time. <strong>click</strong> <br /><br />

                        But while doing it, I wanted to go further than a Mitsuba-like smooth clear-coat. I felt that an energy preserving rough coating was at reach. And fortunately, I could go even further than what I expected. And this model proved to work as well for offline rendering. So I guess that a nice first take home message would be that the constraints of real-time rendering can lead you to very interesting solutions, even for offline.
                    </aside>
                </section>

                <!-- Scope slides -->
                <section>
                    <h2>Layered Materials</h2>
                    <div style="padding:80px 0px 0px 30px; display: flex; align-items: stretch;">
                    <img class="fragment" width="270px" height="270px" style="margin-right: 10px;" src="./images/png/example/clear_coat.png" />
                    <img class="fragment" width="270px" height="270px" style="margin-right: 10px;" src="./images/png/example/frosted_glass.png" />
                    <img class="fragment" width="270px" height="270px" style="margin-right: 10px;" src="./images/png/example/sheen_walls.png" />
                    <img class="fragment" width="270px" height="270px" src="./images/png/example/jewelry.png" />
                    </div>
                    <aside class="notes">
                        Layered materials enable to build a richer set of appearances with relatively simple processes. It is not surprising that they are heavily used in <strong>*click*</strong> car paints, <strong>*click*</strong> furniture design, and <strong>*click*</strong> others applications for paints <strong>*click*</strong> and jewelry.
                    </aside>
                </section>

                <!-- Physical definition -->
                <section>
                        <h2>Layered Materials</h2>
                        <div id="wi" style="position:absolute;top:180px;left:60px;opacity:0;">$\boldsymbol{\omega}_i$</div>
                        <div id="wo" style="position:absolute;top:180px;left:270px;opacity:0;">$\boldsymbol{\omega}_o$</div>
                        <object class="fragment" id="definition" style="position:absolute; width:1280px; top: 100px; left: 0px;" data="./images/svg/drawing.svg"  type="image/svg+xml"></object>
                        <div class="fragment" id="definition_layer1"></div>
                        <!-- <div class="fragment" id="definition_layer2"></div> -->
                        <div class="fragment" id="definition_wi"></div>
                        <div class="fragment" id="definition_wo"></div>
                        <div class="fragment" id="definition_sampling"></div>
                        <div class="fragment" id="definition_ms"></div>
                        <div class="fragment" id="definition_ml"></div>
                        <div class="fragment" id="difficulty_ms"></div>
                        <div class="fragment" id="difficulty_ml"></div>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#definition')[0];
                                s.onload = function() {
                                    var s = Snap("#definition");
                                    s.select("#layer1").attr({ opacity: 0 });
                                    s.select("#layer2").attr({ opacity: 0 });
                                }
                            });

                            Reveal.addEventListener('fragmentshown', function( event ) {
                                if(event.fragment.id == "definition_layer1") {
                                    var s = Snap("#definition");
                                    s.select("#layer1").animate({ opacity: 1 }, 500, callback=function() {
                                        s.select("#layer2").animate({ opacity: 1 }, 500);
                                    });

                                } else if(event.fragment.id == "definition_wi") {
                                    var s = Snap("#definition");
                                    s.select("#wi").animate( {opacity : 1}, 500);
                                    $("#wi").animate({ opacity: 1}, 500);

                                } else if(event.fragment.id == "definition_wo") {
                                    var s = Snap("#definition");
                                    s.select("#wo").animate( {opacity : 1}, 500);
                                    $("#wo").animate({ opacity: 1}, 500);

                                } else if(event.fragment.id == "definition_sampling") {
                                    var s = Snap("#definition");
                                    $("#wo").animate({ opacity: 0}, 500);
                                    s.select("#wo").animate( {opacity : 0}, 500, callback=function(){
                                    s.select("#wi").animate( {opacity : 1}, 500);
                                    s.select("#direct").animate( {opacity : 1}, 500);
                                    s.select("#single").animate( {opacity : 1}, 500);
                                    });

                                } else if(event.fragment.id == "definition_ms") {
                                    var s = Snap("#definition");
                                    s.select("#multiple").animate( {opacity : 1}, 500);

                                } else if(event.fragment.id == "definition_ml") {
                                    var s = Snap("#definition");
                                    s.select("#mlayers").animate( {opacity : 1}, 500);

                                } else if(event.fragment.id == "difficulty_ms") {
                                    var s = Snap("#definition");
                                    s.select("#single").animate( {opacity : 0.1}, 500);
                                    s.select("#direct").animate( {opacity : 0.1}, 500);
                                    s.select("#multiple").selectAll("path").animate( {opacity: 0.1 }, 500);;
                                    s.select("#multiple").select("#multiple_ms").animate( {opacity: 1.0 }, 500);
                                    s.select("#mlayers").animate( {opacity : 0.1}, 500);

                                } else if(event.fragment.id == "difficulty_ml") {
                                    var s = Snap("#definition");

                                    s.select("#multiple").select("#multiple_ms").animate( {opacity: 0.1 }, 500);;
                                    s.select("#mlayers").attr( {opacity: 1.0 } );
                                    s.select("#mlayers").selectAll("path").attr( {opacity: 0.1 } );
                                    s.select("#mlayers").select("#mlayers_ms").animate( {opacity: 1.0 }, 500);

                                }
                            });
                            Reveal.addEventListener('fragmenthidden', function( event ) {
                                if(event.fragment.id == "definition_layer1") {
                                    var s = Snap("#definition");
                                    s.select("#layer2").animate({ opacity: 0 }, 500, callback=function() {
                                        s.select("#layer1").animate({ opacity: 0 }, 500);
                                    });

                                } else if(event.fragment.id == "definition_wi") {
                                    var s = Snap("#definition");
                                    s.select("#wi").animate( {opacity : 0}, 500);
                                    $("#wi").animate({ opacity: 0}, 500);

                                } else if(event.fragment.id == "definition_wo") {
                                    var s = Snap("#definition");
                                    s.select("#wo").animate( {opacity : 0}, 500);
                                    $("#wo").animate({ opacity: 0}, 500);

                                } else if(event.fragment.id == "definition_sampling") {
                                    var s = Snap("#definition");
                                    s.select("#single").animate( {opacity : 0}, 500);
                                    s.select("#direct").animate( {opacity : 0}, 500);
                                    s.select("#wo").animate( {opacity : 1}, 500);
                                    $("#wo").animate({ opacity: 1}, 500);

                                } else if(event.fragment.id == "definition_ms") {
                                    var s = Snap("#definition");
                                    s.select("#multiple").animate( {opacity : 0}, 500);

                                } else if(event.fragment.id == "definition_ml") {
                                    var s = Snap("#definition");
                                    s.select("#mlayers").animate( {opacity : 0}, 500);

                                } else if(event.fragment.id == "difficulty_ms") {
                                    var s = Snap("#definition");
                                    s.select("#single").animate( {opacity : 1.0}, 500);
                                    s.select("#direct").animate( {opacity : 1.0}, 500);
                                    s.select("#multiple").selectAll("path").animate( {opacity: 1.0 }, 500);
                                    s.select("#mlayers").animate( {opacity : 1.0}, 500);


                                } else if(event.fragment.id == "difficulty_ml") {
                                    var s = Snap("#definition");
                                    s.select("#mlayers").animate( {opacity: 0.1 }, 500 );
                                    s.select("#mlayers").selectAll("path").attr( {opacity: 1.0 } );
                                    s.select("#multiple").select("#multiple_ms").animate( {opacity: 1.0 }, 500);
                                }
                            });
                             </script>
                        <aside class="notes">
                            In this talk, we restrict layered materials to be made of a stack of rough dieletric or conducting interfaces <strong>*click*</strong> that are parallel and planar at the macroscopic scale. <strong>*click*</strong> The number of interfaces is however arbitrary. <strong>*click*</strong> <br/><br />

                            We also assume that the material is viewed from sufficiently far away such that light enter and exits the layered structure approximately at the same position. However, for clarity, the illustrations will depict different outgoing position. Keep in mind that those are not accounted in the end. <strong>*click*</strong> <br/><br />

                            The challenge here is the following: Given an incident beam of light, we want to describe light transport in the layered structure <strong>*click*</strong> for any number of scattering events <strong>*click*</strong>. Note that those interaction can be fairly complicated <strong>*click*</strong>. <br/><br />

                            On issue is that <strong>*click*</strong> light can bounce many times between two interfaces or can even <strong>*click*</strong> bounces between many interfaces before reaching the outside.
                        </aside>
                    </section>
                    <section>
                        <h2>Layered Materials</h2>
                        <div style="width:600px; margin:0px 10px 0px 50px;">
                                <ul>
                                    <li>Brute-force rendering is not possible
                                        <ul>
                                            <li>At least not in real-time graphics</li>
                                        </ul>
                                    </li>
                                    <li class="fragment" data-fragment-index="1" style="padding-top:10px;">Precomputation is not statisfactory
                                        <ul>
                                            <li>Forbid to use textured assets</li>
                                            <li>Memory limitation on GPUs</li>
                                        </ul>
                                    </li>
                                    <li class="fragment" data-fragment-index="2" style="padding-top:10px;">Our solution: tight approximation
                                        <!-- <ul>
                                            <li>Based on the real transport</li>
                                        </ul> -->
                                    </li>
                                </ul>
                        </div>
                        <div class="fragment fade-out" data-fragment-index="2" style="position:absolute;top:200px;left:700px;font-size:0.8em;">
                            <center class="fragment fade-in" data-fragment-index="1">
                                <img width="400" src="images/png/range/metallic_paint_layerlab.png" /><br />
                                LayerLab data - 1.7GiB [<a href="">Jakob 2014</a>]
                            </center>
                        </div>
                        <aside class="notes">
                            Real-time constraints prevent us from brute-force rendering of such transport. There, we do not have the budget to sample enough path for a converged estimate. <strong>*click*</strong> <br/><br />

                            Because of the dimensionality of the transport, it is not possible to fully precompute its solution and keep and editable model. <strong>*click*</strong> <br/><br />

                            So instead, I will talk about an approximating method that tries to be as faithful as possible to the real light transport while being compatible with real-time contraints.
                        </aside>
                    </section>

                    <!-- Statistical analysis -->
                    <section>
                        <h2>Our Idea: Sum of GGX Lobes</h2>
                        <div id="sum_of_lobes_wi"  style="position: absolute; top: 230px; left:  50px; color: black; font-size: 1.5em;">$\mathbf{\omega}_i$</div>
                        <div id="sum_of_lobes_wo"  style="position: absolute; top: 200px; left: 170px; color: gray; font-size: 1.5em;">$\mathbf{n}$</div>
                        <div id="sum_of_lobes_rho" style="position: absolute; top: 280px; left: 580px; font-size: 1.5em; opacity: 0;">$$\rho(\mathbf{\omega}_i, \mathbf{\omega}_o) = \sum_{k} w_k \, \rho_k(\mathbf{\omega}_i, \mathbf{\omega}_o)$$</div>
                        <object id="sum_of_lobes" style="position:absolute; width:1280px; top: 180px; left: 0px;" data="./images/svg/outline.svg"  type="image/svg+xml"></object>
                        <div class="fragment" id="sum_of_lobes_1"></div>
                        <div class="fragment" id="sum_of_lobes_2"></div>
                        <div class="fragment" id="sum_of_lobes_3"></div>
                        <div class="fragment" id="sum_of_lobes_4"></div>
                        <div class="fragment" id="sum_of_lobes_5"></div>
                        <div class="fragment" id="sum_of_lobes_6"></div>
                        <div class="fragment" id="sum_of_lobes_7"></div>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#sum_of_lobes')[0];
                                s.onload = function() {
                                    var s = Snap("#sum_of_lobes");
                                    // var g = s.select("#approxGGX");
                                    // var m = g.transform().localMatrix;
                                    // m.translate(0, 0);
                                    // g.attr({ opacity: 1, transform: m.toTransformString() });
                                    s.select("#real_lobes").attr({ opacity: 0 });
                                    s.select("#direct_lobe").attr({ opacity: 0 });
                                    s.select("#first_lobe").attr({ opacity: 0 });
                                    s.select("#second_lobe").attr({ opacity: 0 });
                                    s.select("#direct_arrows").attr({ opacity: 0 });
                                    s.select("#first_arrows").attr({ opacity: 0 });
                                    s.select("#second_arrows").attr({ opacity: 0 });
                                    s.select("#first_path").attr({ opacity: 0 });
                                    s.select("#second_path").attr({ opacity: 0 });


                                    var x, y, size, c1, ps, c2, c3, c4;
                                    x = 60, y = 100; size = 25;
                                    c1 = s.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(s, 6, "#AAF", size, x, y, 2.0, 0.5);
                                    c2 = s.circle(x-0.5*size, y,  1).attr({fill: '#F00'});
                                    c3 = s.circle(x+0.5*size, y,  1).attr({fill: '#63C982'});
                                    c4 = s.circle(x+0.5*size, y, 0.15*size).attr({fill: '#63C982', fillOpacity: 0.3, stroke: '#63C982', strokeWidth: 0.5});
                                    var g = s.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({ id : 'direct_stats', opacity:0 });

                                    x = 150, y = 100; size = 25;
                                    c1 = s.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(s, 6, "#AAF", size, x, y, 2.0, 0.5);
                                    c2 = s.circle(x-0.5*size, y,  1).attr({fill: '#F00'});
                                    c3 = s.circle(x+0.5*size, y,  1).attr({fill: '#E59797'});
                                    c4 = s.circle(x+0.5*size, y, 0.30*size).attr({fill: '#E59797', fillOpacity: 0.3, stroke: '#E59797', strokeWidth: 0.5});
                                    g = s.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({ id : 'first_stats', opacity:0 });

                                    x = 250, y = 100; size = 25;
                                    c1 = s.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(s, 6, "#AAF", size, x, y, 2.0, 0.5);
                                    c2 = s.circle(x-0.5*size, y,  1).attr({fill: '#F00'});
                                    c3 = s.circle(x+0.5*size, y,  1).attr({fill: '#B0C6FC'});
                                    c4 = s.circle(x+0.5*size, y, 0.25*size).attr({fill: '#B0C6FC', fillOpacity: 0.3, stroke: '#B0C6FC', strokeWidth: 0.5});
                                    g = s.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({ id : 'second_stats', opacity:0 });
                                }
                            });

                            Reveal.addEventListener('fragmentshown', function( event ) {
                                var s = Snap("#sum_of_lobes");
                                if(event.fragment.id == "sum_of_lobes_1") {
                                    s.select("#direct_arrows").animate({ opacity: 1 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_2") {
                                    s.select("#first_path").animate({ opacity: 1 }, 1500, callback=function() {
                                        s.select("#first_path").animate({ opacity: 0 }, 500);
                                        s.select("#first_arrows").animate({ opacity: 1 }, 500);
                                    });

                                } else if(event.fragment.id == "sum_of_lobes_3") {
                                    s.select("#second_path").animate({ opacity: 1 }, 1500, callback=function() {
                                        s.select("#second_path").animate({ opacity: 0 }, 500);
                                        s.select("#second_arrows").animate({ opacity: 1 }, 500);
                                    });

                                } else if(event.fragment.id == "sum_of_lobes_4") {
                                    s.select("#direct_stats").animate({ opacity: 1 }, 500, callback=function() {
                                        s.select("#first_stats").animate({ opacity: 1 }, 500, callback=function() {
                                            s.select("#second_stats").animate({ opacity: 1 }, 500);
                                        });
                                    });

                                } else if(event.fragment.id == "sum_of_lobes_5") {
                                    var g = s.select("#direct_stats");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, -20);
                                    g.animate({ transform: m.toTransformString(), opacity: 0 }, 500,  callback=function() {
                                            s.select("#direct_lobe").animate({ opacity: 1 }, 500);
                                    });
                                    g = s.select("#first_stats");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, -20);
                                    g.animate({ transform: m.toTransformString(), opacity: 0 }, 500,  callback=function() {
                                            s.select("#first_lobe").animate({ opacity: 1 }, 500);
                                    });
                                    g = s.select("#second_stats");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, -20);
                                    g.animate({ transform: m.toTransformString(), opacity: 0 }, 500,  callback=function() {
                                            s.select("#second_lobe").animate({ opacity: 1 }, 500);
                                    });

                                } else if(event.fragment.id == "sum_of_lobes_6") {
                                    s.select("#direct_arrows").animate({ opacity: 0 }, 500);

                                    var g = s.select("#first_lobe");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(-85, 0);
                                    g.animate({ transform: m.toTransformString() }, 500);
                                    g = s.select("#first_arrows");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(-85, 0);
                                    g.animate({ transform: m.toTransformString(), opacity:0 }, 500);

                                    g = s.select("#second_lobe");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(-187, 0);
                                    g.animate({ transform: m.toTransformString() }, 500);
                                    g = s.select("#second_arrows");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(-187, 0);
                                    g.animate({ transform: m.toTransformString(), opacity:0 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_7") {
                                    $("#sum_of_lobes_rho").animate({ opacity: 1});
                                }
                            });

                            Reveal.addEventListener('fragmenthidden', function( event ) {

                                var s = Snap("#sum_of_lobes");
                                if(event.fragment.id == "sum_of_lobes_1") {
                                    s.select("#direct_arrows").animate({ opacity: 0 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_2") {
                                    s.select("#first_path").animate({ opacity: 0 }, 500);
                                    s.select("#first_arrows").animate({ opacity: 0 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_3") {
                                    s.select("#second_path").animate({ opacity: 0 }, 500);
                                    s.select("#second_arrows").animate({ opacity: 0 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_4") {
                                    s.select("#direct_stats").animate({ opacity: 0 }, 500);
                                    s.select("#first_stats").animate({ opacity: 0 }, 500);
                                    s.select("#second_stats").animate({ opacity: 0 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_5") {
                                    var g = s.select("#direct_stats");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, 20);
                                    g.animate({ transform: m.toTransformString(), opacity: 1 }, 500,  callback=function() {
                                            s.select("#direct_lobe").animate({ opacity: 0 }, 500);
                                    });
                                    g = s.select("#first_stats");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, 20);
                                    g.animate({ transform: m.toTransformString(), opacity: 1 }, 500,  callback=function() {
                                            s.select("#first_lobe").animate({ opacity: 0 }, 500);
                                    });
                                    g = s.select("#second_stats");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(0, 20);
                                    g.animate({ transform: m.toTransformString(), opacity: 1 }, 500,  callback=function() {
                                            s.select("#second_lobe").animate({ opacity: 0 }, 500);
                                    });

                                } else if(event.fragment.id == "sum_of_lobes_6") {
                                    s.select("#direct_arrows").animate({ opacity: 1 }, 500);

                                    var g = s.select("#first_lobe");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(86, 0);
                                    g.animate({ transform: m.toTransformString() }, 500);
                                    g = s.select("#first_arrows");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(86, 0);
                                    g.animate({ transform: m.toTransformString(), opacity:1 }, 500);

                                    g = s.select("#second_lobe");
                                    var m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(186, 0);
                                    g.animate({ transform: m.toTransformString() }, 500);
                                    g = s.select("#second_arrows");
                                    m = g.transform().localMatrix;
                                    g.attr({ transform: m.toTransformString() });
                                    m.translate(186, 0);
                                    g.animate({ transform: m.toTransformString(), opacity:1 }, 500);

                                } else if(event.fragment.id == "sum_of_lobes_7") {
                                    $("#sum_of_lobes_rho").animate({ opacity: 0});
                                }
                            });
                        </script>
                        <aside class="notes">
                            Our model works as follow: starting from an incident direction, we virtually group together paths that interact with a specific interface. For example, <strong>*click*</strong>  we group together directly reflected paths, <strong>*click*</strong> or paths that interact with the second interface but not below, and finally in this case <strong>*click*</strong> all the paths that interact a least once with the bottom interface. <strong>*click*</strong> <br /><br />

                            However, we do not explicitly compute those paths and instead work with statistical summary of light transport. In the end, each group of paths is described by its zero, first and second order statistics. <strong>*click*</strong> <br /><br />

                            From each set of statistics, we instantiate a GGX microfacet model that approximate those statistics. In this talk, I will refer to those instantiated models as GGX lobes. <strong>*click*</strong> And our approximate BRDF <strong>*click*</strong> consists in the sum of those models.
                        </aside>
                    </section>
                    <section data-state="ggx_statistics">
                        <h2>Statistical Analysis: Mapping</h2>
                        <img width="400" class="fragment fade-in" data-fragment-index="1" id="ortho-proj" style="position:absolute;top:200px;left:780px;border:none;box-shadow:none;" src="images/svg/sideproj.svg" />
                        <div style="display:flex;height:500px;">
                            <div style="width:60%;margin:0px 0px 0px 50px;">
                                <ul>
                                    <li style="padding-bottom: 20px;">We study BSDF statistics
                                        <ul>
                                            <li class="fragment" data-fragment-index="1">In the orthographicaly projected disc</li>
                                            <li class="fragment" data-fragment-index="2" id="shift-ortho-proj">There, GGX is <em>almost</em> rotationaly symmetric</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <div id="our-div-proj" style="position:relative;align-self:center;top:0px;opacity:0;">
                                <canvas id="ggx_statistics" width="512" height="512" style="position:absolute;top:0px;left:0px;width:350px;height:350px;"></canvas>
                                <svg id="ggx_stats_svg" width="350px" height="350px" style="position:absolute;top:0px;left:0px;pointer-events:none;"></svg>
                                <div style="padding-top:360px;width:350px;font-size:0.6em;text-align: center;">Orthographic projection<br />GGX lobe with $\alpha = 0.01$</div>
                            </div>
                        </div>
                        <script>
                            Reveal.addEventListener('ggx_statistics', function( event ) {
                                var snap = Snap("#ggx_stats_svg");
                                ProjectiveSpace(snap, 6, "#AAF", 175);

                                var shader_files = ['./shaders/vertex.shader', './shaders/ggx.shader'];
                                Shaders.generateShaderFromFiles(shader_files, function(shaders) {
                                    var scene = new THREE.Scene();
                                    var camera = new THREE.OrthographicCamera(-1, 1, -1, 1, 0.01, 1000.0);

                                    var canvas = $("#ggx_statistics");
                                    if(canvas.size < 1) {
                                        alert("No Viewport found");
                                    }
                                    var renderer = new THREE.WebGLRenderer({ canvas: canvas[0],
                                                                             alpha : true,
                                                                             antialias: true,
                                                                             preserveDrawingBuffer: true });

                                    var uniforms = {
                                        wi:      { value: [0, 0, 1] },
                                        u_Alpha: { value: 0.01 },
                                        u_Scale: { value: 1.0 },
                                        u_Gamma: { value: 1.0 }
                                    };
                                    var material = new THREE.ShaderMaterial({
                                                            uniforms:       uniforms,
                                                            vertexShader:   shaders[0],
                                                            fragmentShader: shaders[1]
                                                    });
                                    var geometry = new THREE.PlaneGeometry(2, 2);
                                    var plane    = new THREE.Mesh(geometry, material)
                                    scene.add(plane);

                                    camera.position.x = 0;
                                    camera.position.y = 0;
                                    camera.position.z = -10;
                                    camera.up = new THREE.Vector3(0,1,0);
                                    camera.lookAt(new THREE.Vector3(0,0,0));
                                    camera.matrixWorldNeedsUpdate = false;

                                    render = function () {
                                        var t    = (Date.now() / 50.0);
                                        var sint = -0.49*(1.0 + Math.cos(2.0*Math.PI * (t % 100) / 100.0));
                                        var cost = Math.sqrt(1.0 - sint*sint);
                                        uniforms.wi.value = [sint, 0.0, cost];

                                        renderer.render(scene, camera);
                                        window.setTimeout(render, 33);
                                    }

                                    render();
                                }, baseUrl='');
                            });

                            Reveal.addEventListener('fragmentshown', function(event) {
                                if(event.fragment.id == "shift-ortho-proj") {
                                    $("#ortho-proj").animate({ top: 0, opacity: 0 }, 500, callback=function() {
                                        $("#our-div-proj").animate( {opacity: 1} );
                                    });
                                }
                            })
                        </script>
                        <aside class="notes">
                            Lets have a look at how statistics can describe microfacet models. <strong>*click*</strong> <br/><br />

                            We used the hemisphere of directions orthographically projected onto the tangent plane to study the BRDF lobe statistics. <strong>*click*</strong> We do so because in this space, a GGX microfacet model has a shape that is close to being rotationally symmetric and this permits to restrict the number of statistics to study to only three values: the energy, the mean and the variance of the BRDF lobe.
                        </aside>
                    </section>
                    <section data-state="ggx_statistics_2">
                        <h2>Statistical Analysis: Mapping</h2>
                        <div style="display:flex;height:500px;">
                            <div style="width:60%;margin:0px 0px 0px 50px;">
                                <ul>
                                    <li style="padding-bottom:20px; opacity: 0.5;">We study BSDF statistics
                                        <ul>
                                            <li>In the orthographicaly projected disc</li>
                                            <li>There, GGX is <em>almost</em> rotationaly symmetric</li>
                                        </ul>
                                    </li>
                                    <li style="padding-bottom: 20px;">To find a mapping
                                        <ul>
                                            <li>From the three moments (<em>energy, mean, variance</em>)</li>
                                            <li>To a BRDF lobe parameters (<em>albedo, view, roughness</em>)</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <div data-fragment-index="1" id="our-div" style="position:relative;align-self:center;">
                                <!-- <canvas id="ggx_statistics" width="512" height="512" style="position:absolute;top:0px;left:0px;width:350px;height:350px;"></canvas> -->
                                <svg id="ggx_stats_2_svg" width="350px" height="350px" style="position:absolute;top:0px;left:0px;pointer-events:none;"></svg>
                                <div style="padding-top:360px;width:350px;font-size:0.6em;text-align: center;">Orthographic projection<br />Equivalent Statistics</div>
                                <div style="position:absolute;top:180px;left:77px;color:red">$\mathbf{\omega}_i$</div>
                                <div style="position:absolute;top:195px;left:210px;color:#0F0;text-align: center;">$(e, \mathbf{\mu}, \sigma)$</div>
                            </div>
                            <!-- <object id="variance_vs_alpha" style="width:500px;" data="./images/svg/variance_vs_alpha.svg" type="image/svg+xml"></object> -->
                        </div>
                        <script>
                            Reveal.addEventListener('ggx_statistics_2', function( event ) {
                                var snap = Snap("#ggx_stats_2_svg");
                                var size = 175;
                                snap.circle(size, size, size).attr({fill: '#000'});
                                ProjectiveSpace(snap, 6, "#AAF", size);

                                // Stats
                                snap.circle(size-87, size, 5).attr({fill: '#F00'});
                                snap.circle(size+87, size, 5).attr({fill: '#0F0'});
                                snap.circle(size+87, size, 25).attr({fill: '#0F0', fillOpacity: 0.3, stroke: '#0F0', strokeWidth: 2});
                            });
                        </script>
                        <aside class="notes">
                            We can do so because there is a bijective mapping between those statistical moments and the BRDF lobe parameters that are the directional albedo, the view direction and the roughness.
                        </aside>
                    </section>
                    <section data-state="ggx_statistics_3">
                        <h2>Statistical Analysis: Mapping</h2>
                        <div style="display:flex;height:500px;">
                            <div style="width:60%;margin:0px 0px 0px 50px;">
                                <ul>
                                    <li style="padding-bottom:20px; opacity: 0.5;">We study BSDF statistics
                                        <ul>
                                            <li>In the orthographicaly projected disc</li>
                                            <li>There, GGX is <em>almost</em> rotationaly symmetric</li>
                                        </ul>
                                    </li>
                                    <li style="padding-bottom: 20px; opacity: 0.5;">To find a mapping
                                        <ul>
                                            <li>From the three moments (<em>energy, mean, variance</em>)</li>
                                            <li>To a BRDF lobe parameters (<em>albedo, view, roughness</em>)</li>
                                        </ul>
                                    </li>
                                    <li>Can we find the statistics of layered materials?</li>
                                </ul>
                            </div>
                            <div style="width:500px;">
                                <object id="ggx_stats_3_svg" style="width:100%;margin-top:70px;" data="./images/svg/drawing.svg"  type="image/svg+xml"></object><br />
                                <div style="width:500px;font-size:0.6em;text-align:center;font-style:italic;">Layered configuration</div>
                            </div>
                        </div>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#ggx_stats_3_svg')[0];
                                s.onload = function() {
                                    var snap = Snap("#ggx_stats_3_svg");
                                    snap.select('#draw').before(snap.rect(1, 1, 337, 190).attr({fill: '#FFF'}));

                                    snap.rect(1, 1, 337, 188).attr({fillOpacity: 0, stroke: '#000', strokeWidth: 1.5});

                                    var g = snap.select("#approxGGX");
                                    var m = g.transform().localMatrix;
                                    m.translate(-100, 0);
                                    g.attr({ opacity: 1, transform: m.toTransformString() });
                                    snap.select("#lobe1").attr({ opacity: 0 });
                                    snap.select("#lobe2").attr({ opacity: 0 });
                                    snap.select("#lobe3").attr({ opacity: 0 });

                                    var x = 270, y = 60;
                                    var size = 50;
                                    snap.circle(x, y, size).attr({fill: '#000'});
                                    ProjectiveSpace(snap, 6, "#AAF", size, x, y, 4);
                                    // Stats
                                    snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    snap.circle(x+0.5*size, y,  2).attr({fill: '#0F0'});
                                    snap.circle(x+0.5*size, y, 0.25*size).attr({fill: '#0F0', fillOpacity: 0.3, stroke: '#0F0', strokeWidth: 1});
                                    snap.circle(x+0.5*size, y, 0.16*size).attr({fill: '#00F', fillOpacity: 0.3, stroke: '#00F', strokeWidth: 1});
                                }
                            });
                        </script>
                        <aside class="notes">
                            So this is the setup of our model: given an incident direction, we need to find a set of statistics that approximate well the layered BRDF. Those statistics will instantiate multiple BRDF models that will render the correct appearance.
                        </aside>
                    </section>
                    <section>
                        <h2>Statistical Analysis: Framework</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li id="infer_stats">Infer statistics <strong>atomically</strong>
                                    <ul>
                                        <li>Details in the paper</li>
                                        <li>Update $e$, $\mu$, and $\sigma$</li>
                                    </ul>
                                </li>
                                <li class="fragment" id="statistical_operators_01">
                                    Example: refraction operator
                                    <ul class="fragment" id="statistical_operators_02">
                                        <!-- <li>
                                            Using a fake refraction lobe
                                        </li> -->
                                        <li>
                                            Shift, scales and <em>convolves</em> the incident lobe
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </div><br />
                        <div style="width:600px;" class="fragment" id="statistical_operators_03">
                        $$
                        e_t    = \tilde{\mbox{F}} \, e_i
                        $$
                        </div><br />
                        <div style="width:600px;" class="fragment" id="statistical_operators_03">
                        $$
                        \mu_t    = - \eta_{12} \, \mu_i
                        $$
                        </div><br />
                        <div style="width:600px;" class="fragment" id="statistical_operators_04">
                        $$
                        \sigma_t = \eta_{12} \, \color{blue}{\sigma_i} + \color{red}{s}
                        $$
                        </div>

                        <object id="ggx_framework_svg" style="position:absolute;top:70px;left:100px;width:1280px;" data="./images/svg/operators.svg"  type="image/svg+xml"></object><br />
                        <div id="framework_01_reflection"style="position:absolute;top:600px;left:115px;width:200px;text-align:center;font-size:0.6em;font-style:italic;">Reflection</div>
                        <div id="framework_01_refraction"style="position:absolute;top:600px;left:505px;width:200px;text-align:center;font-size:0.6em;font-style:italic;">Refraction</div>
                        <div id="framework_01_scattering"style="position:absolute;top:600px;left:900px;width:200px;text-align:center;font-size:0.6em;font-style:italic;">Scattering</div>

                        <aside class="notes">
                            Now we have to answer the following question: what are the statistics of light transport in a layered structure? To answer this question, we can build a statistical framework that allows to infer the statistics of radiance after atomic operations such as surface reflection, surface refraction and medium scattering. Those operators are fully detailed in the paper. In this talk, it is sufficient to know that each operator update the statistics of the incident radiance. <strong>*click*</strong><br /><br />

                            Let's take the example of light refracted by a dielectric surface. <strong>*click*</strong><br /><br />

                            The refraction ... <strong>*click*</strong><br /><br />

                            scales the energy due to the average Fresnel term in the incident directional footprint. <strong>*click*</strong><br /><br />

                            shift the mean with respect to the index of refraction ratio. This is a simple translation of Snell's law to the directional statistics. <strong>*click*</strong><br /><br />

                            Another impact is that the incident variance (here in blue) is scaled by the change of interface and increased by a term (here in red) that depends on the surface's roughness. <br /><br />

                            I encourage you to read the paper for more details on those operators.
                        </aside>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#ggx_framework_svg')[0];
                                s.onload = function() {
                                    var snap = Snap("#ggx_framework_svg");
                                    var x = 270, y = 300;
                                    var size = 80;
                                    var c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    var ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    var c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    var c3 = snap.circle(x+0.5*size, y,  2).attr({fill: '#0F0'});
                                    var c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: '#0F0', fillOpacity: 0.3, stroke: '#0F0', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'reflection_lobe'});


                                    x = 650, y = 300; size = 80;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    c3 = snap.circle(x+0.3*size, y,  2).attr({fill: 'orange'});
                                    c4 = snap.circle(x+0.3*size, y, 0.2*size).attr({fill: 'orange', fillOpacity: 0.3, stroke: 'orange', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'refraction_lobe'});


                                    x = 1050, y = 300; size = 80;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    c3 = snap.circle(x+0.5*size, y,  2).attr({fill: '#4144FE'});
                                    c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: '#4144FE', fillOpacity: 0.3, stroke: '#4144FE', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'scattering_lobe'});
                                }
                            });
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                var snap = Snap("#ggx_framework_svg");
                                if(event.fragment.id == "statistical_operators_01") {
                                    snap.select('#reflection_lobe').animate({ opacity: 0 }, 500);
                                    snap.select('#refraction_lobe').animate({ opacity: 0 }, 500);
                                    snap.select('#scattering_lobe').animate({ opacity: 0 }, 500);
                                    snap.select('#reflection').animate({ opacity: 0 }, 500);
                                    snap.select('#scattering').animate({ opacity: 0 }, 500);
                                    $('#ggx_framework_svg').animate({left: 450}, 500);
                                    $('#framework_01_refraction').animate({left: 855}, 500);
                                    $('#framework_01_reflection').animate({opacity: 0}, 500);
                                    $('#framework_01_scattering').animate({opacity: 0}, 500);
                                    $('#infer_stats').animate({ opacity: 0.5});
                                } else if(event.fragment.id == "statistical_operators_02") {
                                    // snap.select('#real_refraction').animate({ opacity: 0.1 }, 500);
                                    // snap.select('#fake_refraction').animate({ opacity: 1 }, 500);
                                    // $('#framework_01_refraction').html("Fake refraction");
                                    // $('#framework_01_refraction').css('color', 'green');
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                var snap = Snap("#ggx_framework_svg");
                                if(event.fragment.id == "statistical_operators_01") {
                                    snap.select('#reflection_lobe').animate({ opacity: 1 }, 500);
                                    snap.select('#refraction_lobe').animate({ opacity: 1 }, 500);
                                    snap.select('#scattering_lobe').animate({ opacity: 1 }, 500);
                                    snap.select('#reflection').animate({ opacity: 1 }, 500);
                                    snap.select('#scattering').animate({ opacity: 1 }, 500);
                                    $('#ggx_framework_svg').animate({left: 100}, 500);
                                    $('#framework_01_refraction').animate({left: 505}, 500);
                                    $('#framework_01_reflection').animate({opacity: 1}, 500);
                                    $('#framework_01_scattering').animate({opacity: 1}, 500);
                                } else if(event.fragment.id == "statistical_operators_02") {
                                    // snap.select('#real_refraction').animate({ opacity: 1 }, 500);
                                    // snap.select('#fake_refraction').animate({ opacity: 0 }, 500);
                                    // $('#framework_01_refraction').html("Refraction");
                                    // $('#framework_01_refraction').css('color', '');
                                }
                            });
                        </script>
                    </section>
                    <!-- TODO : Move the validation away from here ? -->
                    <section data-state="unitary_test_01">
                        <h2>Statistical Analysis: Validation</h2>
                        <div style="margin:0px 0px 50px 50px;">
                            <ul>
                                <li>Interactively testing atomic operators</li>
                            </ul>
                        </div>
                        <div style="position:relative;">
                            <div id="unitary_test_04">
                            <canvas id="unitary_test_01_cv" width="512" height="512" style="position:absolute;top:0px;left:0px;width:350px;height:350px;"></canvas>
                            <svg id="unitary_test_01_svg" width="350px" height="350px" style="position:absolute;top:0px;left:0px;pointer-events:none;"></svg>
                            <div style="position:absolute;width:350px;font-size:0.6em;text-align:center;top:360px;">incident radiance</div>
                            </div>

                            <object id="unitary_test_sc_svg" style="position:absolute;top:-235px;left:80px;width:1280px;" data="./images/svg/operators.svg"  type="image/svg+xml"></object><br />

                            <div id="unitary_test_03">
                                <canvas id="unitary_test_03_cv" width="512" height="512" style="position:absolute;top:0px;left:800px;width:350px;height:350px;"></canvas>
                                <svg id="unitary_test_03_svg" width="350px" height="350px" style="position:absolute;top:0px;left:800px;pointer-events:none;"></svg>
                                <div style="position:absolute;width:350px;font-size:0.6em;text-align:center;top:360px;left:800px;">transmitted radiance</div>
                            </div>
                        </div>
                        <div class="fragment" id="unitary_test_frag_00"></div>
                        <div class="fragment" id="unitary_test_frag_01"></div>
                        <div class="fragment" id="unitary_test_frag_02"></div>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                // Remove the unnecessary elements
                                var s = $('#unitary_test_sc_svg')[0];
                                s.onload = function() {
                                    var snap_sc = Snap("#unitary_test_sc_svg");
                                    snap_sc.select('#reflection').attr({ opacity: 0 });
                                    // snap_sc.select('#arrow').attr({ fillOpacity: 1, opacity: 1 });
                                    snap_sc.select('#scattering').attr({ opacity: 0 });
                                }
                                $("#unitary_test_04").css('opacity', 0);
                                $("#unitary_test_03").css('opacity', 0);
                            });
                            Reveal.addEventListener('unitary_test_01', function( event ) {
                                var snap = Snap("#unitary_test_01_svg");
                                ProjectiveSpace(snap, 6, "#AAF", 175);

                                snap = Snap("#unitary_test_03_svg");
                                ProjectiveSpace(snap, 6, "#AAF", 175);
                                snap.text(10, 200, 'reference').attr({ id: 'ref', fontSize: '0.6em', fill: '#F00', opacity: 0 });
                                snap.text(10, 160, 'approximation').attr({ id: 'our', fontSize: '0.6em', fill: '#F00', opacity: 0 });

                                function createThreeCanvas(canvas, shader_files) {
                                    Shaders.generateShaderFromFiles(shader_files, function(shaders) {
                                        // if(canvas.size < 1) {
                                        //     alert("No Viewport found");
                                        // }
                                        canvas.vertex   = shaders[0];
                                        canvas.fragment = shaders[1];

                                        canvas.scene    = new THREE.Scene();
                                        canvas.camera   = new THREE.OrthographicCamera(-1, 1, -1, 1, 0.01, 1000.0);
                                        canvas.renderer = new THREE.WebGLRenderer({ canvas: canvas,
                                                                                    alpha : true,
                                                                                    antialias: true,
                                                                                    preserveDrawingBuffer: true });

                                        canvas.uniforms = {
                                            wi:      { value: [0, 0, 1] },
                                            u_Alpha: { value: 0.01 },
                                            u_Scale: { value: 1.0 },
                                            u_Gamma: { value: 1.0 },
                                            u_ApproxMethod: { value: 0 },
                                            u_CheckReference: { value: 1 },
                                            layers : {value : [{a : 0.0, n: 1.0},
                                                               {a : 0.1, n: 1.5}] },
                                        };
                                        canvas.material = new THREE.ShaderMaterial({
                                                                uniforms:       canvas.uniforms,
                                                                vertexShader:   canvas.vertex,
                                                                fragmentShader: canvas.fragment
                                                        });
                                        canvas.geometry = new THREE.PlaneGeometry(2, 2);
                                        canvas.plane    = new THREE.Mesh(canvas.geometry, canvas.material)
                                        canvas.scene.add(canvas.plane);

                                        canvas.camera.position.x = 0;
                                        canvas.camera.position.y = 0;
                                        canvas.camera.position.z = -10;
                                        canvas.camera.up = new THREE.Vector3(0,1,0);
                                        canvas.camera.lookAt(new THREE.Vector3(0,0,0));
                                        canvas.camera.matrixWorldNeedsUpdate = false;

                                        canvas.render = function () {
                                            var t    = (Date.now() / 50.0);
                                            var sint = -0.49*(1.0 + Math.cos(2.0*Math.PI * (t % 100) / 100.0));
                                            var cost = Math.sqrt(1.0 - sint*sint);
                                            canvas.uniforms.wi.value = [sint, 0.0, cost];

                                            canvas.renderer.render(canvas.scene, canvas.camera);
                                            window.setTimeout(canvas.render, 33);
                                        }

                                        canvas.render();
                                    }, baseUrl='');
                                }

                                var shader_files = ['./shaders/vertex.shader', './shaders/input.shader'];
                                createThreeCanvas($("#unitary_test_01_cv")[0], shader_files);

                                var shader_files = ['./shaders/vertex.shader', './shaders/transmission.shader'];
                                createThreeCanvas($("#unitary_test_03_cv")[0], shader_files);

                            });
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                var snap    = Snap("#unitary_test_03_svg");
                                var snap_sc = Snap("#unitary_test_sc_svg");
                                if(event.fragment.id == "unitary_test_frag_00") {
                                    $("#unitary_test_04").animate({opacity: 1}, 500);
                                } else if(event.fragment.id == "unitary_test_frag_01") {
                                    snap_sc.select('#arrow').animate({ fillOpacity: 1, opacity: 1 }, 500);
                                    $("#unitary_test_03").animate({opacity: 1}, 500);
                                } else if(event.fragment.id == "unitary_test_frag_02") {
                                    snap.select('#ref').animate({ opacity: 1 }, 500);
                                    snap.select('#our').animate({ opacity: 1 }, 500);
                                    $("#unitary_test_03_cv")[0].uniforms.u_CheckReference.value = 0;
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                var snap    = Snap("#unitary_test_03_svg");
                                var snap_sc = Snap("#unitary_test_sc_svg");
                                if(event.fragment.id == "unitary_test_frag_00") {
                                    $("#unitary_test_04").animate({opacity: 0}, 500);
                                } else if(event.fragment.id == "unitary_test_frag_01") {
                                    snap_sc.select('#arrow').animate({ fillOpacity: 0, opacity: 0 }, 500);
                                    $("#unitary_test_03").animate({opacity: 0}, 500);
                                } else if(event.fragment.id == "unitary_test_frag_02") {
                                    snap.select('#ref').animate({ opacity: 0 }, 500);
                                    snap.select('#our').animate({ opacity: 0 }, 500);
                                    $("#unitary_test_03_cv")[0].uniforms.u_CheckReference.value = 1;
                                }
                            });
                        </script>
                        <aside class="notes">
                            We validated the accuracy of our atomic operators with a set of unit test that you can find in our supplemental material. Here I will present the results for the refraction operator. <strong>*click*</strong> <br/><br/>

                            Given an incident beam of light that you can see here highlighted in red. <strong>*click*</strong> <br/><br/>

                            We can compute the ground truth transmitted radiance that you can see on the right. For a roughness of $0.1$ and an IOR of $1.5$.<strong>*click*</strong> <br/><br/>

                            And now here is the approximation. As you can see the approximation is quite close for incidences close to the normal but starts to differ at grazing angles.
                        </aside>
                    </section>

                    <section>
                        <h2>Statistical Analysis: Framework</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li>Multiple layers: chain operators</li>
                            </ul>
                        </div>
                        <div class="fragment" id="multiple_layers_01"></div>
                        <div class="fragment" id="multiple_layers_01b"></div>
                        <div class="fragment" id="multiple_layers_01c"></div>
                        <div class="fragment" id="multiple_layers_02"></div>
                        <div class="fragment" id="multiple_layers_03"></div>
                        <div class="fragment" id="multiple_layers_04"></div>
                        <div class="fragment" id="multiple_layers_05"></div>
                        <div class="fragment" id="multiple_layers_06"></div>
                        <div class="fragment" id="multiple_layers_07"></div>
                        <div class="fragment" id="multiple_layers_08"></div>
                        <div class="fragment" id="multiple_layers_09"></div>
                        <div class="fragment" id="multiple_layers_10"></div>
                        <div class="fragment" id="multiple_layers_11"></div>
                        <div class="fragment" id="multiple_layers_12"></div>
                        <object id="chain_svg" style="position:absolute;top:-20px;left:0px;width:1280px;" data="./images/svg/chaining.svg"  type="image/svg+xml"></object>
                        <aside class="notes">
                            Now that we can summarize light transport at every interface, we need to be able to express the transport for specific groups of light paths. <strong>*click*</strong> <br/><br/>

                            Lets take the following example of a group of light paths refractive two times before being reflected by the bottom interface and leaving the layered structure after two more refractions. <strong>*click*</strong> <br/><br/>

                            In our framework, we use the central path to estimate the statistics. <strong>*click*</strong> This central path is constructed by converting all interfaces as smooth ones. Thus it correspond to a purely specular path. <strong>*click*</strong> <br/><br/>

                            We start at the first vertex of this path and set the statistics to match a dirac in the incident direction. <strong>*click*</strong> <br/><br/>

                            Then, we apply the first operator which in this case is a refraction. <strong>*click*</strong> This will specify the statistics of the outgoing radiance. <strong>*click*</strong> We convert those statistics into incident statistics by mirroring the statistics. and proceed with the next interface. <strong>*click*</strong>

                            We continue this process for the remaining vertices of the path until the outgoing direction is reached. <strong>*click until end*</strong> Note that this example is here to give the intuition of how operators chain together, there exist an infinite number of specular paths and in practice we can not explicitly evaluate them all. Instead, we rely on three mechanisms for efficient evaluation: merging of statistics, analytic form for multiple scattering, and adding-doubling.
                        </aside>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#chain_svg')[0];
                                s.onload = function() {
                                    var snap = Snap("#chain_svg");
                                    var x = 480, y = 360;
                                    var size = 80;
                                    var c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    var ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    var c3 = snap.circle(x-0.5*size, y, 0.25*size).attr({id: 'input_si', fill: '#F00', fillOpacity: 0.3, stroke: '#F00', strokeWidth: 1, opacity: 0.0});
                                    var c2 = snap.circle(x-0.5*size, y,  2).attr({id: 'input_wi', fill: '#F00'});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.attr({id : 'input_lobe', opacity: 0 });


                                    x = 880, y = 360; size = 80;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    c5 = snap.circle(x+0.5*size, y, 0.25*size).attr({id: 'output_so', fill: '#fc9501', fillOpacity: 0.3, stroke: '#fc9501', strokeWidth: 1});
                                    c4 = snap.circle(x+0.5*size, y,  2).attr({id: 'output_wo', fill: '#fc9501'});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c4);
                                    g.add(c5);
                                    g.attr({ id : 'output_lobe', opacity: 0 });

                                    snap.select("#wi").attr({ opacity: 0 });
                                    snap.select("#mlayers").attr({ opacity: 0 });

                                    snap.select("#firstBounce").attr({ opacity: 0 });
                                    snap.select("#secondBounce").attr({ opacity: 0 });
                                    snap.select("#thirdBounce").attr({ opacity: 0 });
                                    snap.select("#fourthBounce").attr({ opacity: 0 });
                                    snap.select("#lastBounce").attr({ opacity: 0 });

                                    snap.select("#reflection").attr({ opacity: 0 });
                                    snap.select("#refraction").attr({ opacity: 0 });
                                    snap.select("#arrow").attr({ opacity: 0 });
                                }
                            });
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                var snap = Snap("#chain_svg");
                                if(event.fragment.id == "multiple_layers_01") {
                                    snap.select("#wi").animate({ opacity : 1 }, 500);
                                    snap.select("#mlayers").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_01b") {
                                    snap.select("#otherPaths").animate({ opacity : 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_01c") {
                                    snap.select("#layer2").animate({ opacity : 0 }, 500);
                                    snap.select("#layer1-3").animate({ opacity : 0 }, 500);
                                    snap.select("#planar").animate({ opacity : 1 }, 500);

                                }  else if(event.fragment.id == "multiple_layers_02") {
                                    snap.select("#input_lobe").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_03") {
                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#refraction").animate({ opacity : 1 }, 500);
                                    snap.select("#input_lobe").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_04") {
                                    snap.select("#output_lobe").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_05") {
                                    snap.select("#input_si").animate({ opacity : 1 }, 500);
                                    snap.select("#input_wi").animate({ opacity : 1 }, 500);
                                    snap.select("#firstBounce").animate({ opacity: 1 }, 500);

                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#refraction").animate({ opacity : 0 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.animate({ transform : m.toTransformString(), opacity: 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_06") {
                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#refraction").animate({ opacity : 1 }, 500);

                                    snap.select("#output_wo").attr({ cx: 900 });
                                    snap.select("#output_so").attr({ cx: 900, r: 10 });

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform : m.toTransformString() });
                                    snap.select("#output_lobe").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_07") {
                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#refraction").animate({ opacity : 0 }, 500);

                                    snap.select("#input_wi").animate({ cx: 460 }, 500);
                                    snap.select("#input_si").animate({ cx: 460, r: 10 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.animate({ transform : m.toTransformString(), opacity: 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_08") {
                                    snap.select("#secondBounce").animate({ opacity: 1 }, 500);

                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#reflection").animate({ opacity : 1 }, 500);

                                    snap.select("#output_wo").attr({ cx: 900, stroke: "#01b009", fill:"#01b009" });
                                    snap.select("#output_so").attr({ cx: 900, r: 22, stroke: "#01b009", fill:"#01b009" });

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform : m.toTransformString() }, 500);
                                    snap.select("#output_lobe").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_09") {
                                    snap.select("#secondBounce").animate({ opacity: 1 }, 500);

                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#reflection").animate({ opacity : 0 }, 500);

                                    snap.select("#input_si").animate({ cx: 460, r: 22 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.animate({ transform : m.toTransformString(), opacity: 0 }, 500);


                                } else if(event.fragment.id == "multiple_layers_10") {
                                    snap.select("#thirdBounce").animate({ opacity: 1 }, 500);
                                    snap.select("#input_wi").animate({ cx: 430 }, 500);
                                    snap.select("#input_si").animate({ cx: 430, r: 22 }, 500);


                                } else if(event.fragment.id == "multiple_layers_11") {
                                    snap.select("#fourthBounce").animate({ opacity: 1 }, 500);
                                    snap.select("#input_wi").animate({ cx: 440 }, 500);
                                    snap.select("#input_si").animate({ cx: 440, r: 18 }, 500);


                                } else if(event.fragment.id == "multiple_layers_12") {
                                    snap.select("#lastBounce").animate({ opacity: 1 }, 500);

                                    snap.select("#arrow").animate({ opacity : 1 }, 500);

                                    snap.select("#input_wi").animate({ cx : 440 }, 500);
                                    snap.select("#input_si").animate({ opacity : 0 }, 500);

                                    // snap.select("#output_wo").attr({ cx: 900 });
                                    snap.select("#output_so").attr({ r: 18 });

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform : m.toTransformString() }, 500);
                                    snap.select("#output_lobe").animate({ opacity : 1 }, 500);
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                var snap = Snap("#chain_svg");
                                if(event.fragment.id == "multiple_layers_01") {
                                    snap.select("#wi").animate({ opacity : 0 }, 500);
                                    snap.select("#mlayers").animate({ opacity : 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_01b") {
                                    snap.select("#otherPaths").animate({ opacity : 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_01c") {
                                    snap.select("#layer2").animate({ opacity : 1 }, 500);
                                    snap.select("#layer1-3").animate({ opacity : 1 }, 500);
                                    snap.select("#planar").animate({ opacity : 0 }, 500);

                                }  else if(event.fragment.id == "multiple_layers_02") {
                                    snap.select("#input_lobe").animate({ opacity : 0 }, 500);

                                }else if(event.fragment.id == "multiple_layers_03") {
                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#refraction").animate({ opacity : 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_04") {
                                    snap.select("#output_lobe").animate({ opacity : 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_05") {
                                    snap.select("#input_si").animate({ opacity : 0 }, 500);
                                    snap.select("#input_wi").animate({ opacity : 1 }, 500);
                                    snap.select("#firstBounce").animate({ opacity: 0 }, 500);

                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#refraction").animate({ opacity : 1 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform: m.toTransformString(), opacity: 0  });

                                } else if(event.fragment.id == "multiple_layers_06") {
                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#refraction").animate({ opacity : 0 }, 500);

                                    snap.select("#output_wo").attr({ cx: 920 });
                                    snap.select("#output_so").attr({ cx: 920, r: 20 });

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.attr({ transform : m.toTransformString() });
                                    snap.select("#output_lobe").animate({ opacity : 0 }, 500);

                                } else if(event.fragment.id == "multiple_layers_07") {
                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#refraction").animate({ opacity : 1 }, 500);

                                    snap.select("#output_wo").attr({ cx: 900, fill: '#fc9501', stroke: '#fc9501' });
                                    snap.select("#output_so").attr({ cx: 900, r: 22, fill: '#fc9501', stroke: '#fc9501' });

                                    snap.select("#input_wi").animate({ cx: 460 }, 500);
                                    snap.select("#input_si").animate({ cx: 460, r: 10 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform : m.toTransformString(), opacity: 1 }, 500);

                                } else if(event.fragment.id == "multiple_layers_08") {
                                    snap.select("#secondBounce").animate({ opacity: 0 }, 500);

                                    snap.select("#arrow").animate({ opacity : 0 }, 500);
                                    snap.select("#reflection").animate({ opacity : 0 }, 500);

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.attr({ transform : m.toTransformString(), opacity : 1 });

                                } else if(event.fragment.id == "multiple_layers_09") {
                                    snap.select("#secondBounce").animate({ opacity: 0 }, 500);

                                    snap.select("#arrow").animate({ opacity : 1 }, 500);
                                    snap.select("#reflection").animate({ opacity : 1 }, 500);

                                    snap.select("#input_si").animate({ cx: 460, r: 22 }, 500);

                                    // Move the output lobe and fade
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(400, 0);
                                    g.attr({ transform : m.toTransformString(), opacity: 1 });


                                } else if(event.fragment.id == "multiple_layers_10") {
                                    snap.select("#thirdBounce").animate({ opacity: 0 }, 500);
                                    snap.select("#input_wi").animate({ cx: 430 }, 500);
                                    snap.select("#input_si").animate({ cx: 430, r: 22 }, 500);


                                } else if(event.fragment.id == "multiple_layers_11") {
                                    snap.select("#fourthBounce").animate({ opacity: 0 }, 500);
                                    snap.select("#input_wi").animate({ cx: 440 }, 500);
                                    snap.select("#input_si").animate({ cx: 440, r: 18 }, 500);


                                } else if(event.fragment.id == "multiple_layers_12") {
                                    snap.select("#lastBounce").animate({ opacity: 0 }, 500);

                                    snap.select("#arrow").animate({ opacity : 0 }, 500);

                                    snap.select("#input_wi").animate({ cx : 440 }, 500);
                                    snap.select("#input_si").animate({ opacity : 1 }, 500);

                                    // Move the output lobe back
                                    var g = snap.select("#output_lobe");
                                    var m = g.transform().localMatrix;
                                    m.translate(-400, 0);
                                    g.attr({ transform : m.toTransformString(), opacity : 0 }, 500);
                                }
                            });
                        </script>
                    </section>
                    <section>
                        <h2>Statistical Analysis: Framework</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li>Merging statistics</li>
                            </ul>
                        </div>
                        <object id="multiple_svg" style="position:absolute;top:-20px;left:0px;width:1280px;" data="./images/svg/multiple.svg"  type="image/svg+xml"></object>
                        <div id="multiple_input_1"   style="width:200px;position:absolute;top:500px;left:570px;text-align:center;font-size:0.8em;">$(e_1, \mu_1, \sigma_1)$</div>
                        <div id="multiple_average_1" style="width:200px;position:absolute;top:550px;left:770px;text-align:center;font-size:1em;opacity:0;">$(e, \mu, \sigma)$</div>
                        <div id="multiple_average_2" style="width:900px;position:absolute;top:540px;left:425px;text-align:center;font-size:1em;opacity:0;">$(e, \mu, \sigma) = \left(e_1+e_2, \mu, \dfrac{e_1}{e}\sigma_1+\dfrac{e_2}{e}\sigma_2\right)$</div>
                        <div id="multiple_input_2"   style="width:200px;position:absolute;top:500px;left:980px;text-align:center;font-size:0.8em;">$(e_2, \mu_2, \sigma_2)$</div>
                        <div id="multiple_average_p" style="width:200px;position:absolute;top:350px;left:770px;text-align:center;font-size:2em;opacity:0;">$+$</div>
                        <div class="fragment" id="multiple_01"></div>
                        <div class="fragment" id="multiple_02"></div>
                        <div class="fragment" id="multiple_03"></div>
                        <aside class="notes">
                            Given two central paths carrying both statistics, <strong>*click*</strong> we need to be able to evaluate the averaged statistics carried by both group of paths. <strong>*click*</strong> Fortunately, central paths will always carry the same mean at the last vertex. <strong>*click*</strong> The  statistics of this group of paths is given by the weighted average of those statistics.
                        </aside>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#multiple_svg')[0];
                                s.onload = function() {
                                    var snap = Snap("#multiple_svg");
                                    var x = 520, y = 325;
                                    var size = 80;
                                    var c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    var ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    var c2 = snap.circle(x-0.5*size, y,  2).attr({id: 'input_wi', fill: '#F00'});
                                    var c5 = snap.circle(x+0.5*size, y, 0.15*size).attr({id: 'input_so', fill: '#f59090', fillOpacity: 0.3, stroke: '#f59090', strokeWidth: 1});
                                    var c4 = snap.circle(x+0.5*size, y,  2).attr({id: 'input_wo', fill: '#f59090'});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c4);
                                    g.add(c5);
                                    g.attr({id : 'output_lobe_1' });

                                    x = 840, y = 325; size = 80;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({id: 'input_wi', fill: '#F00'});
                                    c5 = snap.circle(x+0.5*size, y, 0.25*size).attr({id: 'output_so', fill: '#9096f5', fillOpacity: 0.3, stroke: '#9096f5', strokeWidth: 1});
                                    c4 = snap.circle(x+0.5*size, y,  2).attr({id: 'output_wo', fill: '#9096f5'});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c4);
                                    g.add(c5);
                                    g.attr({ id : 'output_lobe_2' });

                                    x = 680, y = 325; size = 100;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 6);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({id: 'input_wi', fill: '#F00'});
                                    c5 = snap.circle(x+0.5*size, y, 0.2*size).attr({id: 'output_so', fill: '#999', fillOpacity: 0.3, stroke: '#999', strokeWidth: 1});
                                    c4 = snap.circle(x+0.5*size, y,  2).attr({id: 'output_wo', fill: '#999'});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c4);
                                    g.add(c5);
                                    g.attr({ id : 'output_lobe', opacity:0 });
                                }
                            });
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                var snap = Snap("#multiple_svg");
                                if(event.fragment.id == "multiple_01") {
                                    $("#multiple_average_p").animate({ opacity : 1 });

                                } else if(event.fragment.id == "multiple_02") {
                                    $("#multiple_average_p").animate({ opacity : 0 });
                                    $("#multiple_input_1").animate({ opacity : 0 });
                                    $("#multiple_input_2").animate({ opacity : 0 });

                                    // Move the lobes together
                                    var g = snap.select("#output_lobe_1");
                                    var m = g.transform().localMatrix;
                                    m.translate( 100, 0);
                                    g.animate({ transform : m.toTransformString(), opacity : 0 }, 500);

                                    // Move the lobes together
                                    g = snap.select("#output_lobe_2");
                                    m = g.transform().localMatrix;
                                    m.translate(-100, 0);
                                    g.animate({ transform : m.toTransformString(), opacity : 0 }, 500);

                                    snap.select("#output_lobe").animate({ opacity : 1 }, 500);
                                    $("#multiple_average_1").animate({ opacity : 1 });

                                } else if(event.fragment.id == "multiple_03") {
                                    $("#multiple_average_1").animate({ opacity : 0 });
                                    $("#multiple_average_2").animate({ opacity : 1 });
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                var snap = Snap("#multiple_svg");
                                if(event.fragment.id == "multiple_01") {
                                    $("#multiple_average_p").animate({ opacity : 0 });

                                } else if(event.fragment.id == "multiple_02") {
                                    $("#multiple_average_p").animate({ opacity : 1 });
                                    $("#multiple_input_1").animate({ opacity : 1 });
                                    $("#multiple_input_2").animate({ opacity : 1 });

                                    // Move the lobes together
                                    var g = snap.select("#output_lobe_1");
                                    var m = g.transform().localMatrix;
                                    m.translate(-100, 0);
                                    g.animate({ transform : m.toTransformString(), opacity : 1 }, 500);

                                    // Move the lobes together
                                    g = snap.select("#output_lobe_2");
                                    m = g.transform().localMatrix;
                                    m.translate(100, 0);
                                    g.animate({ transform : m.toTransformString(), opacity : 1 }, 500);

                                    snap.select("#output_lobe").animate({ opacity : 0 }, 500);
                                    $("#multiple_average_1").animate({ opacity : 0 });

                                } else if(event.fragment.id == "multiple_03") {
                                    $("#multiple_average_1").animate({ opacity : 1 });
                                    $("#multiple_average_2").animate({ opacity : 0 });
                                }
                            });
                        </script>
                    </section>
                    <section>
                        <h2>Statistical Analysis: Framework</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li style="opacity: 0.5;">Merging statistics</li>
                                <li>Multiple scattering
                                    <ul>
                                        <li>Closed-form statistics</li>
                                        <li>Arithmetico-Geometric series</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <object id="multiple_svg" style="position:absolute;top:-20px;left:0px;width:1280px;" data="./images/svg/multiple_02.svg"  type="image/svg+xml"></object>
                        <aside class="notes">
                            We found out that, in a single layer, there is an closed-form form for the statistics of multiple scattering. In this case, we write the energy and variance as arithmetico-geometric series for which there is a closed-form solution.
                        </aside>
                    </section>
                    <section>
                        <h2>Statistical Analysis: Framework</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li style="opacity: 0.5;">Merging statistics</li>
                                <li style="opacity: 0.5;">Multiple scattering
                                    <ul>
                                        <li>Closed-form statistics</li>
                                        <li>Arithmetico-Geometric series</li>
                                    </ul>
                                </li>
                                <div class="fragment" id="adding_01"></div>
                                <li>Adding-Doubling
                                    <ul>
                                        <li class="fragment" id="adding_02">Adding-Doubling on variance [<a href="">van de Hulst 1962</a>]</li>
                                        <li class="fragment" id="adding_03">Average upper interaction as well</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <object id="adding_svg" style="position:absolute;top:-20px;left:0px;width:1280px;" data="./images/svg/multiple_03.svg"  type="image/svg+xml"></object>
                        <aside class="notes">
                            We associate this finding with a new adding-doubling method. The idea behind the adding-doubling method is to estimate the scattering statistics of a stack of layers by iteratively applying the multiple scattering formula on pairs of layers. <br /><br />

                            I will illustrate here how it works. Let say we want to evaluate the BRDF of the layered structure. Given the incident direction, <strong>*click*</strong> we start by computing the reflected and transmitted directional statistics due to the first interface and record the reflected statistics as our first BRDF lobe. <strong>*click*</strong> Next, we evaluate the multiple scattering between the first two interfaces and record the reflected statistics as our second BRDF lobe. <strong>*click*</strong> Next, we virtually merge these two interfaces of this layer into a single interface. This virtual interface response to an incident beam is defined by the reflected and transmitted statistics. <strong>*click*</strong> Finally, we evaluate the multiple scattering equation using this new layer and record the reflected statistics as the third lobe. Note that the adding-doubling will account for all the multiple scattering happening between the top layers and the current layer considered.
                        </aside>
                        <div class="fragment" id="adding_04"></div>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var s = $('#adding_svg')[0];
                                s.onload = function() {
                                    var snap = Snap("#adding_svg");
                                    snap.select('#reflection').attr({ opacity: 0 });
                                    snap.select('#refraction').attr({ opacity: 0 });
                                    snap.select('#refraction2').attr({ opacity: 0 });
                                    snap.select('#adding_upper').attr({ opacity: 0 });
                                    snap.select('#multiple_bounce_next').attr({ opacity: 0 });

                                    x = 700, y = 180; size = 50;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 4);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    c3 = snap.circle(x+0.5*size, y,  2).attr({fill: 'green'});
                                    c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: 'green', fillOpacity: 0.3, stroke: 'green', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'reflection_lobe_01', opacity: 0});

                                    x = 810, y = 180; size = 50;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 4);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    c3 = snap.circle(x+0.5*size, y,  2).attr({fill: '#F59090'});
                                    c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: '#F59090', fillOpacity: 0.3, stroke: '#F59090', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'reflection_lobe_02', opacity: 0});

                                    x = 920, y = 180; size = 50;
                                    c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 4);
                                    c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    c3 = snap.circle(x+0.5*size, y,  2).attr({fill: '#BBC5DC'});
                                    c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: '#BBC5DC', fillOpacity: 0.3, stroke: '#BBC5DC', strokeWidth: 1});
                                    var g = snap.g();
                                    g.add(c1);
                                    g.add(ps);
                                    g.add(c2);
                                    g.add(c3);
                                    g.add(c4);
                                    g.attr({id : 'reflection_lobe_03', opacity: 0});

                                    // x = 700, y = 400; size = 50;
                                    // c1 = snap.circle(x, y, size).attr({fill: '#000'});
                                    // ps = ProjectiveSpace(snap, 6, "#AAF", size, x, y, 4);
                                    // c2 = snap.circle(x-0.5*size, y,  2).attr({fill: '#F00'});
                                    // c3 = snap.circle(x+0.5*size, y,  2).attr({fill: 'green'});
                                    // c4 = snap.circle(x+0.5*size, y, 0.25*size).attr({fill: 'green', fillOpacity: 0.3, stroke: 'green', strokeWidth: 1});
                                    // var g = snap.g();
                                    // g.add(c1);
                                    // g.add(ps);
                                    // g.add(c2);
                                    // g.add(c3);
                                    // g.add(c4);
                                    // g.attr({id : 'refraction_lobe_01'});
                                }
                            });
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                var snap = Snap("#adding_svg");
                                if(event.fragment.id == "adding_01") {
                                    snap.select('#reflection').animate({ opacity: 1 }, 500);
                                    snap.select('#refraction').animate({ opacity: 1 }, 500);
                                    snap.select('#reflection_lobe_01').animate( {opacity: 1 }, 500);

                                } else if(event.fragment.id == "adding_02") {
                                    snap.select('#adding_upper').animate({ opacity: 1 }, 500);
                                    snap.select('#reflection_lobe_02').animate( {opacity: 1 }, 500);

                                } else if(event.fragment.id == "adding_03") {
                                    var s = -36;
                                    ['#layers_next', "#multiple_bounce_next"].forEach(function(e) {
                                        var g = snap.select(e);
                                        var m = g.transform().localMatrix;
                                        g.attr({ transform: m.toTransformString() });
                                        m.translate(0, s);
                                        g.animate({ transform: m.toTransformString() }, 500);
                                    });
                                    snap.select('#adding_upper').animate({ opacity: 0 }, 500);
                                    snap.select('#refraction').animate({ opacity: 0 }, 500);
                                    snap.select('#refraction2').animate({ opacity: 1 }, 500);

                                } else if(event.fragment.id == "adding_04") {
                                    snap.select('#multiple_bounce_next').animate({ opacity: 1 }, 500);
                                    snap.select('#reflection_lobe_03').animate( {opacity: 1 }, 500);
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                var snap = Snap("#adding_svg");
                                if(event.fragment.id == "adding_01") {
                                    snap.select('#reflection').animate({ opacity: 0 }, 500);
                                    snap.select('#refraction').animate({ opacity: 0 }, 500);
                                    snap.select('#reflection_lobe_01').animate( {opacity: 0 }, 500);

                                } else if(event.fragment.id == "adding_02") {
                                    snap.select('#adding_upper').animate({ opacity: 0 }, 500);
                                    snap.select('#reflection_lobe_02').animate( {opacity: 0 }, 500);

                                } else if(event.fragment.id == "adding_03") {
                                    var s = +36;
                                    ['#layers_next', "#multiple_bounce_next"].forEach(function(e) {
                                        var g = snap.select(e);
                                        var m = g.transform().localMatrix;
                                        g.attr({ transform: m.toTransformString() });
                                        m.translate(0, s);
                                        g.animate({ transform: m.toTransformString() }, 500);
                                    });
                                    snap.select('#adding_upper').animate({ opacity: 1 }, 500);
                                    snap.select('#refraction').animate({ opacity: 1 }, 500);
                                    snap.select('#refraction2').animate({ opacity: 0 }, 500);

                                } else if(event.fragment.id == "adding_04") {
                                    snap.select('#multiple_bounce_next').animate({ opacity: 0 }, 500);
                                    snap.select('#reflection_lobe_03').animate( {opacity: 0 }, 500);
                                }
                            });
                        </script>
                    </section>

                    <!-- Results section -->
                    <section>
                        <h2>Offline Validation</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li><a href="">Mitsuba</a> renderer
                                        <ul>
                                            <li>Both opaque and transparent plugins</li>
                                            <li>Varying number of textured layers</li>
                                            <li><em>Multiple Importance Sampling</em> with the lobes</li>
                                        </ul>
                                </li>
                            </ul>
                        </div>
                        <img style="border:none;position:absolute;left:700px;top:200px;" src="images/png/logos/mitsuba.png" />
                        <aside class="notes">
                            First I will present the validation I made in the Mitsuba renderer. There I implemented two plugins both for opaque and semi-transparent surfaces. Those plugins can take an arbitrary number of layers with every parameter mapped to a texture. I importance sampled each lobe independently and used a multiple importance sampling weighting to aggregate them.
                        </aside>
                    </section>
                    <section>
                        <h2>Offline Validation</h2>
                        <div style="width:900px; margin:0px 0px 0px 50px;">
                                <ul>
                                    <li style="opacity:0.3;"><a href="">Mitsuba</a> renderer</li>
                                    <li style="margin-top:0.5em;">Comparison with stochastic reference</li>
                                </ul>
                        </div>
                        <table style="width:95%; margin: 30px 0px 0px 30px;">
                            <tr>
                                <td>
                                    <div id="validation_metal_foil_bloc" style="position:relative; width:350px; height:350px;">
                                        <img id="validation_metal_foil_ref" width="350px" height="350px" style="margin:0px; position:absolute;" src="./images/png/range/metal_foil_reference.png" />
                                        <img id="validation_metal_foil_our" width="350px" height="350px" style="top:1px;left:1px;margin:0px; position:absolute;box-shadow: none;clip: rect(0px,0px,350px,0px); frame: 0; border:none;" src="./images/png/range/metal_foil_symmetric.png" />
                                        <div id="validation_metal_foil_ref_txt" style="position:absolute; top:300px; left:0; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Ours</div>
                                        <div id="validation_metal_foil_our_txt" style="position:absolute; top:300px; left:175px; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Reference</div>
                                        <div id="validation_metal_foil_sep" style="position:absolute;top:1px;left:0px; height:333px; width:0px; border-left:solid black 2px; opacity:0;" ></div>
                                    </div>
				                </td>
                                <td>
                                    <div id="validation_rough_metal_bloc" style="position:relative; width:350px; height:350px;">
                                        <img id="validation_rough_metal_ref" width="350px" height="350px" style="margin:0px; position:absolute;" src="./images/png/range/rough_rough_metal_reference.png" />
                                        <img id="validation_rough_metal_our" width="350px" height="350px" style="top:1px;left:1px;margin:0px; position:absolute;box-shadow: none;clip: rect(0px,0px,350px,0px); frame: 0; border:none;" src="./images/png/range/rough_rough_metal_symmetric.png" />
                                        <div id="validation_rough_metal_ref_txt" style="position:absolute; top:300px; left:0; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Ours</div>
                                        <div id="validation_rough_metal_our_txt" style="position:absolute; top:300px; left:175px; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Reference</div>
                                        <div id="validation_rough_metal_sep" style="position:absolute;top:1px;left:0px; height:333px; width:0px; border-left:solid black 2px; opacity:0;" ></div>
                                    </div>
				                </td>
                                <td>
                                    <div id="validation_gold_coated_bloc" style="position:relative; width:350px; height:350px;">
                                        <img id="validation_gold_coated_ref" width="350px" height="350px" style="margin:0px; position:absolute;" src="./images/png/range/gold_coated_reference.png" />
                                        <img id="validation_gold_coated_our" width="350px" height="350px" style="top:1px;left:1px;margin:0px; position:absolute;box-shadow: none;clip: rect(0px,0px,350px,0px); frame: 0; border:none;" src="./images/png/range/gold_coated_symmetric.png" />
                                        <div id="validation_gold_coated_ref_txt" style="position:absolute; top:300px; left:0; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Ours</div>
                                        <div id="validation_gold_coated_our_txt" style="position:absolute; top:300px; left:175px; width: 175px; font-size:0.8em; text-align:center; color:gainsboro; opacity:0;">Reference</div>
                                        <div id="validation_gold_coated_sep" style="position:absolute;top:1px;left:0px; height:333px; width:0px; border-left:solid black 2px;" ></div>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td style="width:350px; font-size: 0.9em; text-align: center;">Metal foil</td>
                                <td style="width:350px; font-size: 0.9em; text-align: center;">Rough metal</td>
                                <td style="width:350px; font-size: 0.9em; text-align: center;">Gold Coated</td>
                            </tr>
                        </table>
                        <div class="fragment" id="validation_metal_foil_01"></div>
                        <script>
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                if(event.fragment.id == "validation_metal_foil_01") {
                                    $('#validation_metal_foil_our_txt').animate({ opacity: 1}, 500);
                                    $('#validation_metal_foil_ref_txt').animate({ opacity: 1}, 500);
                                    $('#validation_metal_foil_sep').css('opacity', 1);
                                    $('#validation_metal_foil_our').animate({ frame: '170'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_metal_foil_sep").css('left', now);
                                        }
                                    });

                                    $('#validation_rough_metal_our_txt').animate({ opacity: 1}, 500);
                                    $('#validation_rough_metal_ref_txt').animate({ opacity: 1}, 500);
                                    $('#validation_rough_metal_sep').css('opacity', 1);
                                    $('#validation_rough_metal_our').animate({ frame: '170'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_rough_metal_sep").css('left', now);
                                        }
                                    });

                                    $('#validation_gold_coated_our_txt').animate({ opacity: 1}, 500);
                                    $('#validation_gold_coated_ref_txt').animate({ opacity: 1}, 500);
                                    $('#validation_gold_coated_our').animate({ frame: '170'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_gold_coated_sep").css('left', now);
                                        }
                                    });
                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                if(event.fragment.id == "validation_metal_foil_01") {
                                    $('#validation_metal_foil_our_txt').animate({ opacity: 0}, 500);
                                    $('#validation_metal_foil_ref_txt').animate({ opacity: 0}, 500);
                                    $('#validation_metal_foil_our').animate({ frame: '0'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_metal_foil_sep").css('left', now);
                                        }
                                    });

                                    $('#validation_rough_metal_our_txt').animate({ opacity: 0}, 500);
                                    $('#validation_rough_metal_ref_txt').animate({ opacity: 0}, 500);
                                    $('#validation_rough_metal_our').animate({ frame: '0'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_rough_metal_sep").css('left', now);
                                        }
                                    });

                                    $('#validation_gold_coated_our_txt').animate({ opacity: 0}, 500);
                                    $('#validation_gold_coated_ref_txt').animate({ opacity: 0}, 500);
                                    $('#validation_gold_coated_our').animate({ frame: '0'}, {
                                        duration: 1000,
                                        step: function(now, fx) {
                                            $(this).css('clip', 'rect(0px, '+(now)+'px, 350px, 0px)');
                                            $("#validation_gold_coated_sep").css('left', now);
                                        }
                                    });
                                }
                            });
                        </script>
                        <aside class="notes">
                            I validated that the predicted appearance was close to the reference. For that I used a stochastically evaluated ground truth. There, paths inside the layered structure are randomly sampled. <strong>*click*</strong> As shown in this comparison, the approximation stays close visualy from the reference.
                        </aside>
                    </section>
                    <section>
                        <h2>Offline Validation</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li style="opacity:0.3;"><a href="">Mitsuba</a> renderer</li>
                                <li style="margin-top:0.5em; opacity:0.3;">Comparison with stochastic reference</li>
                                <li style="margin-top:0.5em;">Layered method of Weidlich &amp; Wilkie [<a href="">2007</a>]</li>
                            </ul>
                        </div>
                        <div class="fragment">
                            <div style="position:absolute; width:350px; height:350px; top:320px; left:300px;">
                                <img width="350px" height="350px" style="border:none; margin:0px; position:absolute;" src="./images/png/range/frosted_metal_reference.png" />
                                <img width="350px" height="350px" style="border:none; margin:0px; position:absolute;box-shadow: none;clip: rect(0px,165px,350px,0px); frame: 0; border:none;" src="./images/png/range/frosted_metal_symmetric.png" />
                                <div style="position:absolute; top:300px; left:  0px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Ours</div>
                                <div style="position:absolute; top:300px; left:165px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Reference</div>
                                <div style="position:absolute; top:  1px; left:165px; width:   0px; height:332px; border-left:solid black 2px;" ></div>
                                <div style="position:absolute; top:  0px; left:  0px; width: 330px; height:330px; border:solid black 2px;" ></div>
                            </div>

                            <div style="position:absolute; width:350px; height:350px; top:320px; left:700px;">
                                <img width="350px" height="350px" style="border:none; margin:0px; position:absolute;" src="./images/png/range/frosted_metal_reference.png" />
                                <img width="350px" height="350px" style="border:none; margin:0px; position:absolute;box-shadow: none;clip: rect(0px,165px,350px,0px); frame: 0; border:none;" src="./images/png/range/frosted_metal_weidlich.png" />
                                <div style="position:absolute; top:300px; left:  0px; width:165px; font-size:0.8em; text-align:center; color:gainsboro;">[WW07]</div>
                                <div style="position:absolute; top:300px; left:165px; width:165px; font-size:0.8em; text-align:center; color:gainsboro;">Reference</div>
                                <div style="position:absolute; top:  1px; left:165px; width:  0px; height:333px;  border-left:solid black 2px;" ></div>
                                <div style="position:absolute; top:  0px; left:  0px; width: 330px; height:330px; border:solid black 2px;" ></div>
                            </div>
                        </div>
                        <aside class="notes">
                            I also validated those results regarding the model of Weidlich and Wilkie that is currently considered as the state of the art in industry. <strong>*click*</strong> In this example, the material consist of a rough dielectric on top of a smooth mirror. Because the model of Weidlich and Wilkie decouples more the evaluation of the different layers compared to ours, it differs significantly from the reference.

                            <!-- We outperform the industrie standard -->
                        </aside>
                    </section>
                    <section>
                        <h2>Offline Validation</h2>
                        <div style="margin:0px 0px 0px 50px;">
                            <ul>
                                <li style="opacity:0.3;"><a href="">Mitsuba</a> renderer</li>
                                <li style="margin-top:0.5em; opacity:0.3;">Comparison with stochastic reference</li>
                                <li style="margin-top:0.5em; opacity:0.3;">Layered method of Weidlich &amp; Wilkie [<a href="">2007</a>]</li>
                                <li style="margin-top:0.5em;">Multiple scattering
                            </ul>
                        </div>
                        <center class="fragment" style="margin-top:0em;">
                            <table>
                                <tr>
                                    <td><img width="300px" height="300px" style="margin-bottom:0px;" src="./images/png/range/gold_coated_ref_single.png" /></td>
                                    <td><img width="300px" height="300px" style="margin-bottom:0px;" src="./images/png/range/gold_coated_reference.png"  /></td>
                                    <td><img width="300px" height="300px" style="margin-bottom:0px;" src="./images/png/range/gold_coated_symmetric.png"  /></td>
                                </tr>
                                <tr style="padding-top:-50px;">
                                    <!-- Single reflection, multiple reflection -->
                                    <td><div style="text-align:center; font-size:0.8em;">$R + TRT$</div></td>
                                    <td><div style="text-align:center; font-size:0.8em;">$R + TR^+T$</div></td>
                                    <td><div style="text-align:center; font-size:0.8em;">Ours</div></td>
                                </tr>
                            </table>
                        </center>
                        <aside class="notes">
                            Finally, I validated that the model is energy preserving <strong>*click*</strong> and approximate the color saturation due to multiple scattering between different layers quite correctly. On the bottom are shown three rough gold sphere with a rough coating. On the left you can see the reference solution with where the light paths are restricted to only one reflection. This doesn't include multiple scattering between the two interfaces as shown in the middle. Notice how saturated the multiple scattering is.
                        </aside>
                    </section>

                    <section>
                        <h2>Offline Results: Textures</h2>
                        <table style="margin-top:100px;">
                            <tr>
                                <td class="fragment" data-fragment-index="1"><video width="380px" data-autoplay loop src="./videos/plate.m4v" id="video_plate_01"></video></td>
                                <td class="fragment" data-fragment-index="2" id="result_plate_01"><video width="380px" data-autoplay loop src="./videos/plate_waterdrops.m4v" id="video_plate_02"></video></td>
                                <td class="fragment" data-fragment-index="3" id="result_plate_02"><video width="380px" data-autoplay loop src="./videos/plate_dielectric.m4v"></video></td>
                            </tr>
                            <tr>
                                <td class="fragment" data-fragment-index="1" style="text-align: center; font-size:0.8em;">Textured base $\alpha$</td>
                                <td class="fragment" data-fragment-index="2" style="text-align: center; font-size:0.8em;">Textured top  $\eta$</td>
                                <td class="fragment" data-fragment-index="3" style="text-align: center; font-size:0.8em;">Textured top $\alpha$</td>
                            </tr>
                        </table>
                        <script>
                        Reveal.addEventListener( 'fragmentshown', function( event ) {
                            if(event.fragment.id == "result_plate_01") {
                                var drag_video = $('#video_plate_01')[0];
                                // drag_video.currentTime = 0;
                                drag_video.pause();
                                $('#video_plate_01').animate({ opacity: 0.3 });
                            } else if(event.fragment.id == "result_plate_02") {
                                var drag_video = $('#video_plate_02')[0];
                                // drag_video.currentTime = 0;
                                drag_video.pause();
                                $('#video_plate_02').animate({ opacity: 0.3 });
                            }
                        });
                        </script>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Offline Results: Robot Bust</h2>
                        <div style="display: flex;">
                            <div style="width:600px; margin:0px 0px 0px 50px;">
                                <ul>
                                    <li class="fragment" style="padding:0px 0px 10px 0px;">Two layer configuration</li>
                                    <li class="fragment" style="padding:0px 0px 10px 0px;">Multiple textured layers
                                        <ul>
                                            <li>Base and top Index of Refraction</li>
                                            <li>Top roughness</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <img width="512" src="images/png/robot/robot.png" />
                        </div>
                        <aside class="notes">
                            Now lets have a look at more eye-candy results. In this scene, we have a robot <strong>*click*</strong> covered with a two-layers paint. <strong>*click*</strong> Both the base and top layer resp. real and complex IOR are textured as well as the top roughness. This validate that this model works well with textured data.
                        </aside>
                    </section>
                    <section>
                        <h2>Offline Results: Robot Bust</h2>
                        <center style="width:100%">
                            <video style="width:80%" data-autoplay src="./videos/robot.mov"></video>
                        </center>
                        <aside class="notes">
                            Here we scale the texture from a constant to the texture value by interpolation. When we rotate the bust to see the angular effects.
                        </aside>
                    </section>
                    <section>
                            <h2>Offline Results: Dragon</h2>
                            <div style="display: flex;">
                                <div style="width:600px; margin:0px 0px 0px 50px;">
                                        <ul>
                                            <li style="padding:0px 0px 10px 0px;">Gold metal dragon</li>
                                            <li class="fragment" id="result_dragon_01" style="padding:0px 0px 10px 0px;">Adding a medium layer
                                                <ul>
                                                    <li>Simulate dust</li>
                                                    <li>Increase the haze</li>
                                                </ul>
                                            </li>
                                        </ul>
                                </div>
                                <div class="fragment" id="result_dragon_02"></div>
                                <div style="position:relative; width:500px; height:400px; top: 70px; left: -50px;">
                                    <video id="dragon_vid" style="position:absolute; margin:0px; max-width:100%; max-height:100%;" width="500" height="400"  src="./videos/dragon.mov"></video>
                                    <img   id="dragon_top" style="clip:rect(0px, 0px, 400px, 0px);  box-shadow:none; frame:0; position:absolute; margin:0px; max-width:100%;max-height:100%; border:none;" width="500" height="400" src="images/png/dragon/dragon_d=0_sym.png" />
                                    <div   id="dragon_lbl" style="border-left:solid black 2px;position:absolute;left:0px;top:0px;height:402px;margin:0px;"></div>
                                    <video id="dragon_rot" style="position:absolute; box-shadow:none; margin:0px; max-width:100%; max-height:100%; opacity:0;" width="500" height="400" loop src="./videos/dragon-rotate.mov"></video>
                                    <div   style="border:solid black 2px;position:absolute;left:0px;top:0px;height:400px;width:500px;"></div>
                                </div>
                            </div>
                            <aside class="notes">
                                In this example, we illustrate the ability of the model to incorporate effets from participating medium between layers. We start from a gold metallic dragon and <strong>*click*</strong> add a layer of dust modeled using a forward participating media. This increases the haze of the appearance. <strong>*click*</strong> And here is the comparison when we remove the dust layer.
                            </aside>

                            <script>
                            var dragon_continue = false;
                            function animate_dragon() {
                                var next_anim = undefined;
                                if(dragon_continue) {
                                    dragon_continue = false;
                                    next_anim = animate_dragon;
                                }

                                $('#dragon_top').animate({ frame: '500'}, {
                                    duration: 2000,
                                    step: function(now, fx) {
                                        $(this).css('clip', 'rect(0px, '+(now)+'px, 400px, 0px)');
                                        $("#dragon_lbl").css('left', now);
                                    }
                                });
                                $('#dragon_top').animate({ frame: '0'}, {
                                    duration: 2000,
                                    step: function(now, fx) {
                                        $(this).css('clip', 'rect(0px, '+(now)+'px, 400px, 0px)');
                                        $("#dragon_lbl").css('left', now);
                                    },
                                    complete: next_anim
                                });
                            }
                            Reveal.addEventListener( 'fragmentshown', function( event ) {
                                if(event.fragment.id == "result_dragon_01") {

                                    var drag_video = $('#dragon_vid')[0];
                                    drag_video.currentTime = 0;
                                    drag_video.play();
                                } else if(event.fragment.id == "result_dragon_02") {
                                    dragon_continue = true;
                                    animate_dragon();
                                } else if(event.fragment.id == "result_dragon_03") {
                                    dragon_continue = false;
                                    var drag_rot = $('#dragon_rot');
                                    drag_rot[0].currentTime = 3.5;
                                    drag_rot[0].pause();
                                    drag_rot.animate({ opacity : 1}, {
                                        duration: 500,
                                        complete: drag_rot[0].play()
                                    });


                                }
                            });
                            Reveal.addEventListener( 'fragmenthidden', function( event ) {
                                if(event.fragment.id == "result_dragon_01") {
                                    dragon_continue = false;
                                }
                            });
                        </script>
                    </section>
                    <section>
                        <h2>Real-Time Results in Unity</h2>
                        <center class="fragment" style="width:100%">
                            <video style="width:80%" data-autoplay controls src="./videos/beetle_sequence.mp4" id="video_beetle"></video>
                        </center>
                        <script>
                            Reveal.addEventListener('ready', function( event ) {
                                var video = $("#video_beetle")[0];
                                video.volume = 0.0;
                            });
                        </script>
                        <aside class="notes">
                            Last, lets look at the results obtained in the Unity engine. <strong>*click*</strong> This video showcase an editing session in the editor, recorded on a desktop PC with an Nvidia GTX 980. In the shader implementation, the number of layers is set three: first a dieletic coat, then a participating media and last a conducting base. Thanks to the efficiency of the model and because we do not precompute data per material, a user can edit the layer material in real-time and change the base color the top IOR and roughness... As you can see, verything is real-time.
                        </aside>
                    </section>

                    <!-- Limitation section -->
                    <section>
                        <h2>Limitations: High Roughnesses</h2>
                        <div style="width:100%; display: flex; justify-content:space-between; margin-top:100px; transform: scale(0.8);">
                            <div style="position:relative; width:330px; height:330px;">
                                <img id="diffuse_bot" style="position:absolute; margin:0px; max-width:100%; max-height:100%;" width="512"  src="images/png/failure/failure3_reference.png" />
                                <img id="diffuse_top" style="clip:rect(0px, 165px, 512px, 0px); box-shadow:none; position:absolute; margin:0px; max-width:100%;max-height:100%;" width="512" src="images/png/failure/failure3_symmetric.png" />
                                <div id="diffuse_lbl" style="border-left:solid black 2px;position:absolute;left:165px;top:1px;height:332px;margin:0px;"></div>
                                <div style="position:absolute;top:340px;width:330px;margin:0px;text-align:center;">$\alpha = 0.3$</div>

                                <div style="position:absolute; top:300px; left:  0px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Ours</div>
                                <div style="position:absolute; top:300px; left:165px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Reference</div>
                            </div>

                            <div style="position:relative; width:330px; height:330px;">
                                <img id="diffuse_bot" style="position:absolute; margin:0px; max-width:100%; max-height:100%;" width="512"  src="images/png/failure/failure2_reference.png" />
                                <img id="diffuse_top" style="clip:rect(0px, 165px, 512px, 0px); box-shadow:none; position:absolute; margin:0px; max-width:100%;max-height:100%;" width="512" src="images/png/failure/failure2_symmetric.png" />
                                <div id="diffuse_lbl" style="border-left:solid black 2px;position:absolute;left:165px;top:1px;height:332px;margin:0px;"></div>
                                <div style="position:absolute;top:340px;width:330px;margin:0px;text-align:center;">$\alpha = 0.6$</div>

                                <div style="position:absolute; top:300px; left:  0px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Ours</div>
                                <div style="position:absolute; top:300px; left:165px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Reference</div>
                            </div>

                            <div style="position:relative; width:330px; height:330px;">
                                <img id="diffuse_bot" style="position:absolute; margin:0px; max-width:100%; max-height:100%;" width="512"  src="images/png/failure/failure1_reference.png" />
                                <img id="diffuse_top" style="clip:rect(0px, 165px, 512px, 0px); box-shadow:none; position:absolute; margin:0px; max-width:100%;max-height:100%;" width="512" src="images/png/failure/failure1_symmetric.png" />
                                <div id="diffuse_lbl" style="border-left:solid black 2px;position:absolute;left:165px;top:1px;height:332px;margin:0px;"></div>
                                <div style="position:absolute;top:340px;width:330px;margin:0px;text-align:center;">$\alpha = 0.9$</div>

                                <div style="position:absolute; top:300px; left:  0px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Ours</div>
                                <div style="position:absolute; top:300px; left:165px; width: 165px; font-size:0.8em; text-align:center; color:gainsboro;">Reference</div>
                            </div>
                        </div>
                        <aside class="notes">
                            Before concluding, I would like to stress a limitation of the statistical analysis. We built our work on approximations of the scattering operators that are valid for low roughness. Thus, the statistical approximation becomes inaccurate for higher roughness values.
                        </aside>
                    </section>

                    <!-- Summary section -->
                    <section>
                        <h2>Summary</h2>
                        <video style="position:absolute; top:0; left: 330px; margin: 0; border: none; box-shadow: none; max-width: 100%; max-height: 100%; z-index: -500;" height="100%" width="100%" data-autoplay loop src="./videos/robot.mov"></video>
                        <div style="position:absolute; top:0; left: 0px; margin: 0; max-width: 100%; max-height: 100%; z-index: -5; width: 720px; height:720px; background-color: #DDD "></div>
                        <div style="display: flex;">
                              <div style="width:600px; margin:0px 0px 0px 50px;">
                                    <ul>
                                       <li class="fragment" style="padding:0px 0px 10px 0px;">A <strong>novel</strong> BSDF model for layered structures
                                                <ul>
                                                      <li>Accurate for low roughnesses</li>
                                                      <li>Accounts from multiple scattering</li>
                                                      <li>No parameter dependent precomputation</li>
                                                      <li>Compatible with real-time scenario</li>
                                                </ul>
                                          </li>
                                          <li class="fragment" style="padding:0px 0px 10px 0px;">Our <strong>contributions</strong>
                                                <ul>
                                                      <li>Statistical analysis of light transport in layers</li>
                                                      <li>New adding-doubling scheme for variance</li>
                                                </ul>
                                          </li>
                                    </ul>
                              </div>
                        </div>
                        <aside class="notes">
                            To summarize, <strong>*click*</strong> I presented a novel BSDF model to handle layered materials efficiently. This model is very accurate for low roughnesses, preserves energy, doesn't not have parameter dependent precomputation allowing it to work with textured inputs. <strong>*click*</strong> <br/><br/>

                            To achieve this, we made the following contribution: we developped a statistical analysis of light transport in layered structures and introduced an adding-doubling strategy for second order directional statistics.
                        </aside>
                    </section>
                    <section><h2>Thank you for your attention</h2>
                        <center style="padding-top: 70px;">
                        <table>
                            <tr>
                                <td style="padding-bottom: 0px;"><img style="width: 256px; border: none; box-shadow: none; margin: 0px;" src="./images/png/end/paper.png" /></td>
                                <td style="padding-bottom: 0px;"><img style="width: 256px; border: none; box-shadow: none; margin: 0px;" src="./images/png/end/supp.png" /></td>
                                <td style="padding-bottom: 0px;"><img style="width: 256px; border: none; box-shadow: none; margin: 0px;" src="./images/png/end/code.png" /></td>
                                <td style="padding-bottom: 0px;"><img style="width: 256px; border: none; box-shadow: none; margin: 0px;" src="./images/png/end/hdrp.png" /></td>
                            </tr>
                            <tr>
                                <td style="padding-top: 0px; position:relative; left: 60px; font-size: 0.7em;">paper</td>
                                <td style="padding-top: 0px; position:relative; left: 45px; font-size: 0.7em;">supp. mat.</td>
                                <td style="padding-top: 0px; position:relative; left: 65px; font-size: 0.7em;">code</td>
                                <td style="padding-top: 0px; position:relative; left: 65px; font-size: 0.7em;">HDRP StackLit</td>
                            </tr>
                        </table>
                        </center>

                        <center style="padding-top: 80px;">available at <a href="https://belcour.github.io/blog/research/2018/05/05/brdf-realtime-layered.html">belcour.github.io/blog</a></center>
                        <aside class="notes">
                            I encourage you to check out our paper and our supplementary pdf and code. Thank you for your attention.
                        </aside>
                    </section>
            </div>
        </div>
        <script>
            Reveal.initialize({
                  width: 1280,
                  height: 720,
                  margin: 0.0,
                  history: true,
                  showNotes: true,
                  transition: 'fade',
                  controls: false,
                  slideNumber: 'c/t',

                  math: {
		            mathjax: 'ext/mathjax/MathJax.js',
		            config: 'TeX-AMS_SVG-full'  // See http://docs.mathjax.org/en/latest/config-files.html
	            },

                  dependencies: [
                        { src: 'ext/reveal.js/plugin/math/math.js', async: true },
                        { src: 'ext/reveal.js/plugin/notes/notes.js', async: true }
                  ]
            });

            // Create WebGL canvas
            createCanvas();


            // Update the context to the current sldie
            Reveal.addEventListener('slidechanged', function( event ) {
                var element = $(event.currentSlide).find("div.webgl");
                if(element.length > 0) {
                    replaceElement(element, Reveal.getScale());
                }

            });
        </script>
    </body>
</html>

